# ============================================================================
# NEXO PLATFORM - CD Reusable Workflow
# ============================================================================
# Workflow reutiliz√°vel para deploy de qualquer servi√ßo em qualquer ambiente.
# Padr√£o GitOps: Atualiza o values.yaml com a nova tag e ArgoCD faz o sync.
# ============================================================================

name: _CD Reusable

on:
  workflow_call:
    inputs:
      service:
        description: "Nome do servi√ßo"
        required: true
        type: string
      environment:
        description: "Ambiente de deploy (dev, qa, staging, prod)"
        required: true
        type: string
      image_tag:
        description: "Tag da imagem a ser deployada"
        required: true
        type: string
      helm_chart_path:
        description: "Caminho do Helm Chart"
        required: true
        type: string
      values_file:
        description: "Arquivo de values do ambiente"
        required: true
        type: string
      namespace:
        description: "Namespace Kubernetes"
        required: true
        type: string
      target_branch:
        description: "Branch alvo para push das atualiza√ß√µes"
        required: true
        type: string
      auto_sync:
        description: "Habilitar auto-sync no ArgoCD"
        required: false
        type: boolean
        default: false
      require_approval:
        description: "Requer aprova√ß√£o manual"
        required: false
        type: boolean
        default: false
    secrets:
      DOCKERHUB_USERNAME:
        required: false
      DOCKERHUB_TOKEN:
        required: false
      GH_TOKEN:
        required: false

env:
  REGISTRY: docker.io
  IMAGE_NAME: geraldobl58/${{ inputs.service }}

jobs:
  # ============================================
  # Job 1: Valida√ß√£o Pr√©-Deploy
  # ============================================
  validate:
    name: üîç Validate
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: "3.14.0"

      - name: Lint Helm Chart
        run: |
          helm lint ${{ inputs.helm_chart_path }} \
            --values ${{ inputs.values_file }}

      - name: Template Helm Chart
        run: |
          helm template ${{ inputs.service }}-${{ inputs.environment }} \
            ${{ inputs.helm_chart_path }} \
            --values ${{ inputs.values_file }} \
            --set image.tag=${{ inputs.image_tag }} \
            --namespace ${{ inputs.namespace }}

      - name: Validate Kubernetes manifests
        uses: instrumenta/kubeval-action@master
        with:
          files: |
            helm template ${{ inputs.service }}-${{ inputs.environment }} \
              ${{ inputs.helm_chart_path }} \
              --values ${{ inputs.values_file }}
        continue-on-error: true

  # ============================================
  # Job 2: Aprova√ß√£o (Staging/Prod)
  # ============================================
  approval:
    name: ‚è≥ Approval
    runs-on: ubuntu-latest
    needs: validate
    if: inputs.require_approval
    environment:
      name: ${{ inputs.environment }}
      url: https://${{ inputs.service }}.${{ inputs.environment }}.nexo.io
    steps:
      - name: Approval Check
        run: |
          echo "‚úÖ Deployment approved for ${{ inputs.service }} to ${{ inputs.environment }}"
          echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ inputs.image_tag }}"

  # ============================================
  # Job 3: Update Image Tag in Git (GitOps)
  # ============================================
  deploy:
    name: üöÄ Deploy
    runs-on: ubuntu-latest
    needs: [validate, approval]
    if: always() && needs.validate.result == 'success' && (needs.approval.result == 'success' || needs.approval.result == 'skipped')
    environment:
      name: ${{ inputs.environment }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.target_branch }}
          token: ${{ secrets.GH_TOKEN || github.token }}
          fetch-depth: 0

      - name: Setup yq
        uses: mikefarah/yq@master

      - name: Update commit annotation in values file
        run: |
          VALUES_FILE="${{ inputs.values_file }}"
          COMMIT_SHA="${{ github.sha }}"
          SHORT_SHA="${COMMIT_SHA:0:7}"

          echo "üìù Updating $VALUES_FILE with commit: $SHORT_SHA"

          # Update the podAnnotations.app.kubernetes.io/commit in the values file
          yq e '.podAnnotations."app.kubernetes.io/commit" = "'$SHORT_SHA'"' -i "$VALUES_FILE"

          # Show the change
          echo "‚úÖ Updated podAnnotations:"
          yq e '.podAnnotations' "$VALUES_FILE"

      - name: Commit and Push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          SHORT_SHA="${{ github.sha }}"
          SHORT_SHA="${SHORT_SHA:0:7}"

          # Check if there are changes
          if git diff --quiet; then
            echo "‚ÑπÔ∏è No changes to commit (commit already up to date)"
          else
            git add ${{ inputs.values_file }}
            # [skip ci] √© reconhecido pelo GitHub Actions e evita loops
            # O CI tem l√≥gica para N√ÉO pular em merges de PR
            git commit -m "deploy(${{ inputs.environment }}): ${{ inputs.service }} ‚Üí ${SHORT_SHA} [skip ci]"
            
            # Pull with rebase to handle parallel pushes
            for i in 1 2 3 4 5; do
              git pull --rebase origin ${{ inputs.target_branch }} && break
              echo "‚ö†Ô∏è Rebase attempt $i failed, retrying..."
              sleep $((i * 2))
            done
            
            git push
            echo "‚úÖ Pushed new commit annotation to Git"
          fi

      - name: Notify ArgoCD to Sync
        env:
          ARGOCD_SERVER: ${{ vars.ARGOCD_SERVER }}
          ARGOCD_AUTH_TOKEN: ${{ vars.ARGOCD_AUTH_TOKEN }}
        run: |
          APP_NAME="${{ inputs.service }}-${{ inputs.environment }}"
          echo "üîÑ Notifying ArgoCD to refresh ${APP_NAME}..."

          if [ -n "$ARGOCD_SERVER" ] && [ -n "$ARGOCD_AUTH_TOKEN" ]; then
            # Trigger hard refresh
            curl -s -X GET \
              "https://$ARGOCD_SERVER/api/v1/applications/${APP_NAME}?refresh=hard" \
              -H "Authorization: Bearer $ARGOCD_AUTH_TOKEN" \
              --insecure || echo "‚ö†Ô∏è Could not refresh, ArgoCD will sync automatically"
            
            echo "‚úÖ ArgoCD notified!"
          else
            echo "‚ÑπÔ∏è ArgoCD will auto-sync within 60 seconds"
          fi

      - name: Summary
        run: |
          echo "üéâ Deployment initiated!"
          echo "Service: ${{ inputs.service }}"
          echo "Environment: ${{ inputs.environment }}"
          echo "Image Tag: ${{ inputs.image_tag }}"
          echo ""
          echo "üìã Git updated with new tag. ArgoCD will sync automatically."

  # ============================================
  # Job 4: Post-Deploy Verification
  # ============================================
  verify:
    name: ‚úÖ Verify
    runs-on: ubuntu-latest
    needs: deploy
    steps:
      - name: Deployment Complete
        run: |
          echo "üéâ Deployment pipeline completed!"
          echo "Service: ${{ inputs.service }}"
          echo "Environment: ${{ inputs.environment }}"
          echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ inputs.image_tag }}"
          echo ""
          echo "üìã Flow: Git updated ‚Üí ArgoCD detects change ‚Üí Pods recreated with new image"
